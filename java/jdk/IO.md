###### IO模型

- 阻塞IO
  - 工作线程一直等待fd就绪。
- 非阻塞IO
  - 不用等，马上返回一个fd无event。
  - 可能需要工作线程重复获取才能得到一个fd event。
- 多路复用IO
  - 不用等，马上返回一个fd无event
  - 有一个专门的线程去轮询所有无event的df，询问到有event才调用实际的IO操作
    - 该线程在内核，效率比用户线程高得多
    - 因为只有一个线程处理IO，当响应体很大时会影响整体轮询
  - JAVA NIO使用这个
    - 通过selector.select()去查询每个通道是否有event
    - 无event时会一直阻塞，导致用户线程阻塞
- 信号驱动IO
  - 用户线程发起IO请求时会注册一个信号函数，然后继续执行
  - 内核数据就绪时发一个信号给用户线程
  - 用户线程调用IO执行实际需要的操作
- 异步IO
  - 用户线程发起read操作后，可以立即执行其他任务
  - 内核接收到这个read操作请求后，等待数据准备就绪拷贝到用户线程并通知用户线程
  - 用户线程直接读数据
- 与信号驱动IO的区别
  - 信号驱动IO只是告诉工作线程有IO可用了，实际上工作线程还会去执行IO
  - 异步IO内核已经帮你完成了IO操作，工作线程可以直接拿数据

###### JAVA NIO

- 三大核心
  - Channel
    - 对比传统IO中的Stream，不同在于Channel是读写双向的
    - 包括FileChannel, DatagramChannel, SocketChannel和ServerSocketChannel
  - Buffer
    - 其实就是一个连续数组，数据存放的容器
    - 一个顶层抽象父类
    - 客户端或者服务端读写总要通过buffer到channel
  - Selector
    - 跟多路复用的内核轮询线程差不多意思，但是这玩意还是属于工作线程，不是内核线程
- 与传统JAVA IO区别
  - 传统JAVA IO
    - 基于字节流和字符流操作，面向流，阻塞。
    - 要移动流读取数据先要将其缓存到缓冲区
  - NIO
    - 基于Channel和Buffer操作，面向缓冲区，非阻塞。
    - 可以前后移动缓冲区灵活获取需要的数据
      - 灵活移动的前提是，当前缓冲区需要的数据已经处理完毕，否则旧数据会被覆盖

###### 补充-linux 几种多路复用IO

- select
  - 几乎所有平台支持
  - 有fd限制，32未默认1024,64位默认2048
  - 线性扫描，效率低。
  - 需要维护一个存储大量fd的数据结构，增大了用户空间到内核空间的复制开销
- poll
  - 与select没有本质区别。
  - 基于链表实现，无fd上限，但是复制开销一样大
  - 水平触发：报告了fd如果没有处理，那么下次poll还会继续报告
- epoll
  - 2.6内核开始
  - 使用一个fd管理多个fd，无fd上限。利用mmap文件映射减少复制开销
  - 边缘触发：只告诉进程哪些fd就绪，不用轮询，而且只通知一次。

