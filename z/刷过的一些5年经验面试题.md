#### 说明

有阵子刷了一批公司的面试，大厂小厂都有，有些过了， 也有面得一塌糊涂的。闲暇之余把一些当时没答出来的、答得不好的、觉得有意思或者仅仅是还有印象的问题整理了一下。

不一定所有都会写答案，不过尽量补上。

#### 题目

1. 手写递归代码

   ```java
   /**
   * 实现从start开始，在不大于max值之前按start递增1倍输出，超过max值时输出一次，再逆序输出至start。
   * 如： p(1,7); 输出1 2 4 8 4 2 1
   */
   public void p(int start,int max){
       System.out.print(start+" ");
       if(start < max){
           p(start*2,max);
           System.out.print(start+" ");
       }
   }
   ```

   

2. docker配置jvm参数

3. thrift服务端一般采用io多路复用模型，上下文切换开销并不小，那为什么还要这样用？

   开销不小好过阻塞。

4. mysql索引与主键本质区别

   索引存的是主键，主键存的才是行数据（innoDB，myISAM都是存行数据）

5. dockerfile执行add remove add同一个100M的jar包，最终镜像大小是多少？

   300M

6. 64位机上，一般jvm内存设置不要超过多少？（常出在陷阱题）

   32g内。0-4g在32位环境下，4字节指针即可完成内存寻址，4-32g为64位环境，但是jvm有个指针压缩技术，能通过偏移量形式仍然使用4字节指针寻址，所以速度一样很快。超过32g后，只能用8字节指针寻址，代价约为1.5倍，据说需要40-50g的内存才能实际达到32g效果。另外内存过大，gc也会比较大负荷。

7. jvm utils的使用，包括查看gc情况，高载cpu线程等等。

8. mysql数据分库分表垂直拆分数据不均匀怎么处理？

9. 异地多活解决方案深入探讨

10. linux排查java进程cpu暴增过程

11. mysql主从同步，如果master高载了怎么处理？

12. linux下报错：too many opened files，并发现一大堆close_wait的tcp该怎么处理？

    有tcp连接没关，代码问题。

13. mq选型，为什么项目用a不用b

14. 数据库设计注意事项

15. 微服务选型，为什么要用微服务，从什么角度去拆分微服务

16. 版本更迭怎么去设计，尽可能避免过于频繁的重构

17. kafka的堆内存怎么设置比较合理

    陷阱题，原则上不要超过32g都行，可以配得比较小，因为零拷贝技术和os cache的使用。

18. redis god key

    这个实在没找到

19. 同一个线程能否递归调用一个包含可重入锁的方法

    废话。

20. 简述两种gc回收对象算法

    1. 引用计数法
       - 每次引用计数器+1
       - 不用了-1
       - 计数器为0的即为可回收
    2. gc root
       - 所有有引用的对象均能链接到root，无论是直接到达，还是经过若干层链路到达
       - 链接不到root的对象即为可回收

21. 一致性哈希怎么解决分布不均问题

    哈希环上复制多个虚拟节点，虚拟节点其实对应的还是当前的几个节点。

22. 简述静态代理与动态代理，什么场景会使用上

23. 分布式事务深入探讨

24. 缓存击穿、缓存穿透处理方式

    - 缓存击穿
      - 信号量互斥（其实类似分布式锁），一次只允许一个去更新，其他的等更新就行
    - 缓存穿透
      - 查出写一个特定空值到缓存，并设置一个相对短的失效时间
      - 使用布隆过滤器排除掉没有的数据
        - 多次哈希，值分别散列到一个数组
        - 命中的不一定有，但是没命中的肯定是没有的
        - 可在较小内存内直接使用

25. core dump详解

26. haproxy健康检查机制

    配个参数就行(check)，实际通过简单的三次握手(对tcp)

27. nginx失败快速转移配置

    ```nginx
    #失败1次后，60秒内不再请求到这个
    server 127.0.0.1:8080 max_fails=1 fail_timeout=60s;
    ```

    

28. 线程池拒绝策略

29. thrift底层实现

30. 