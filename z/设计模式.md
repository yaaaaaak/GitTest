##### 六大原则

比较概念性的东西，先简单过一遍。

###### 开闭原则（Open Close Principle）

开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

###### 里氏代换原则（Liskov Substitution Principle）

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科

###### 依赖倒转原则（Dependence Inversion Principle）

这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。

###### 接口隔离原则（Interface Segregation Principle）

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

###### 迪米特法则（最少知道原则）（Demeter Principle）

为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

###### 合成复用原则（Composite Reuse Principle）

原则是尽量使用合成/聚合的方式，而不是使用继承。

##### 常见23种设计模式

总的来说，设计模式可以划分3类：创造类、结构类、行为类。

创造类包括：工厂模式、抽象工厂模式、单例模式、原型模式、建造者模式

结构类包括：

行为类包括：

###### 工厂模式

比较好理解，通过工厂对象获取需要的对象。

###### 抽象工厂模式

如果需要从工厂需要多种类型Demo，那么需要频繁修改工厂方法，无论是对调用方还是制作方都很不方便，因此衍生出抽象工厂模式。

简单来说就是使工厂抽象化，然后提供一个统一的生产接口，返回对象也是一个抽象类。这样各自需要的时候去实现这个工厂生产接口，按需返回自己所要的对象即可。

###### 单例模式

在[java基础](../java/jdk/java基础.md)里有详细说明，理解起来也相对简单些，当不允许创建多个实例时会用上。

###### 原型模式

简单来说就是在不修改原有数据的基础上，能对对象进行拷贝操作，要注意的是，继承clone接口只是浅复制，还需要考虑深拷贝的问题，一般实现序列化接口可解决。

###### 建造者模式

简单理解就是我们为对象提供一系列可修改其自身的方法。最常见的应该是setter方法。



###### 适配器模式

解决了多版本接口的不兼容问题，对外提供的不一定同名接口。

###### 装饰模式

对接口的增强，比如额外增加一些操作，一般装饰者与被装饰者为持有关系。

###### 代理模式

屏蔽掉调用方对接口细节的了解，对外提供的是同一个名字的接口。

以上三种模式很像，不过目的都不一样。

适配器模式为解决兼容而生。

装饰模式是为了操作增强。

代理模式对外屏蔽细节。

待完善